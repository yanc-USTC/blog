<!DOCTYPE html><html lang="ch-zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>线性表 | yanc的主页</title><meta name="author" content="Yan Cheng"><meta name="copyright" content="Yan Cheng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="这篇文章是作者的课堂笔记，主要介绍了线性表的基本概念、基本操作和实现方法。">
<meta property="og:type" content="article">
<meta property="og:title" content="线性表">
<meta property="og:url" content="https://yanc-blog.zeabur.app/2024/09/25/ch2/index.html">
<meta property="og:site_name" content="yanc的主页">
<meta property="og:description" content="这篇文章是作者的课堂笔记，主要介绍了线性表的基本概念、基本操作和实现方法。">
<meta property="og:locale" content="ch_ZH">
<meta property="og:image" content="https://cdn.pixabay.com/photo/2024/07/06/08/10/flowers-8876324_1280.png">
<meta property="article:published_time" content="2024-09-24T16:00:00.000Z">
<meta property="article:modified_time" content="2024-09-27T08:26:53.023Z">
<meta property="article:author" content="Yan Cheng">
<meta property="article:tag" content="课堂笔记">
<meta property="article:tag" content="线性表">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.pixabay.com/photo/2024/07/06/08/10/flowers-8876324_1280.png"><link rel="shortcut icon" href="/img/image.jpg"><link rel="canonical" href="https://yanc-blog.zeabur.app/2024/09/25/ch2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":10,"languages":{"author":"Author: Yan Cheng","link":"Link: ","source":"Source: yanc的主页","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-center"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '线性表',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-27 16:26:53'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/image.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">2</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://cdn.pixabay.com/photo/2024/07/06/08/10/flowers-8876324_1280.png')"><nav id="nav"><span id="blog-info"><a href="/" title="yanc的主页"><img class="site-icon" src="/img/image.jpg"/><span class="site-name">yanc的主页</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">线性表</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-09-24T16:00:00.000Z" title="Created 2024-09-25 00:00:00">2024-09-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-09-27T08:26:53.023Z" title="Updated 2024-09-27 16:26:53">2024-09-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">4.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>18mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="线性表"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、线性表的基本概念"><a href="#一、线性表的基本概念" class="headerlink" title="一、线性表的基本概念"></a>一、线性表的基本概念</h1><h2 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h2><h3 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h3><p>线性结构：描述数据元素之间存在的一对一逻辑关系，即在非空有限数据集中，逻辑相邻数据元素之间存在的序偶关系</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/46936670/1725952189173-15ce144f-b7ec-4356-945d-8ca819a3a4fd.jpeg"></p>
<h3 id="线性表（Linear-List）"><a href="#线性表（Linear-List）" class="headerlink" title="线性表（Linear List）"></a>线性表（Linear List）</h3><blockquote>
<p>具有线性结构的同类数据元素构成的有限序列</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/46936670/1725955899101-a0d40194-9143-4ec5-abad-4aab1b4c2439.jpeg"></p>
<p>线性表的特点</p>
<ul>
<li>同构性:由同类数据元素组成，所有元素必须属于同一数据对象</li>
<li>有穷性:由有限数据元素组成，数据元素的个数n称为表长</li>
<li>线性:相邻数据元素之间是一对一序偶关系，相对位置编号i称为位序</li>
</ul>
<h3 id="线性表的抽象数据类型定义（ADT定义）"><a href="#线性表的抽象数据类型定义（ADT定义）" class="headerlink" title="线性表的抽象数据类型定义（ADT定义）"></a>线性表的抽象数据类型定义（ADT定义）</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/46936670/1725956484140-35b192ac-cb2a-44ff-947b-6816d3dac70f.jpeg"></p>
<h2 id="线性表的基本操作"><a href="#线性表的基本操作" class="headerlink" title="线性表的基本操作"></a>线性表的基本操作</h2><h3 id="线性表的基本操作集"><a href="#线性表的基本操作集" class="headerlink" title="线性表的基本操作集"></a>线性表的基本操作集</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/46936670/1725956548947-84bf12c0-5926-4d24-a275-04a754e37a80.jpeg"></p>
<p>基本操作集的特点：</p>
<ul>
<li>抽象性：仅声明函数接口，定义输入输出，描述基本功能，不涉及语言和实现</li>
<li>基础性：对特定数据结构进行的最基本、最频繁使用的操作，是复杂操作的基础</li>
<li>非完备性：面向不同应用的基本操作可以根据需要自行定义</li>
</ul>
<p>:::tips<br>例2.1 已知两个线性表<code>La</code>和<code>Lb</code>分别表示集合$ A $和$ B $，求集合$ A&#x3D;A∪B $，即将并集的结果仍存储在<code>La</code>中。</p>
<p>算法设计思路: </p>
<ol>
<li>从首元素开始，依次访问<code>Lb</code>的数据元素</li>
<li>检查该元素是否已存在于<code>La</code>中，若已经存在，则返回执行1</li>
<li>若不存在，则将其插入到<code>La</code>的尾部，并重复执行1</li>
</ol>
<p>:::</p>
<h3 id="类C伪代码（推荐）"><a href="#类C伪代码（推荐）" class="headerlink" title="类C伪代码（推荐）"></a>类C伪代码（推荐）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*将所有在线性表Lb中但不在La中的数据元素合并到La中*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">union</span><span class="params">(List &amp;La, List Lb)</span> &#123;</span><br><span class="line">    La_len = GetListLength(La); </span><br><span class="line">    Lb_len = GetListLength(Lb);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= Lb_len; i++) &#123; </span><br><span class="line">        GetElem(Lb, i, &amp;e); <span class="comment">//取Lb中第i个数据元素赋给e</span></span><br><span class="line">        <span class="keyword">if</span> (!LocateElem(La, e, Equal())) </span><br><span class="line">            <span class="comment">//查询e在La中的位序，若不存在则将e插入La尾部</span></span><br><span class="line">            InsertElem(&amp;La, ++La_len, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、线性表的顺序表示"><a href="#二、线性表的顺序表示" class="headerlink" title="二、线性表的顺序表示"></a>二、线性表的顺序表示</h1><h2 id="顺序表的定义"><a href="#顺序表的定义" class="headerlink" title="顺序表的定义"></a>顺序表的定义</h2><h3 id="线性表的顺序表示（顺序表）"><a href="#线性表的顺序表示（顺序表）" class="headerlink" title="线性表的顺序表示（顺序表）"></a>线性表的顺序表示（顺序表）</h3><p>顺序表：采用<strong>顺序存储结构</strong>表示的线性表，即用一组<strong>地址连续的存储单元依次存储</strong>线性表的数据元素</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/46936670/1725958118100-74a44e71-b6c8-46e3-a781-0d8feb7fb175.jpeg"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/46936670/1725958156675-2d788448-50d5-46c5-8eec-6872fdd3db20.jpeg"></p>
<p>顺序表的随机存取特点：</p>
<ol>
<li>采用顺序存储结构或顺序映像，占用一片连续的存储单元</li>
<li>表内逻辑结构上相邻的数据元素的物理地址相邻</li>
<li>表内任一数据元素的存储位置都与其位序i成正比</li>
<li>基地址确定后，表中任一数据元素均可随机存取</li>
</ol>
<h3 id="顺序表的数据类型定义（一维数组表示法）"><a href="#顺序表的数据类型定义（一维数组表示法）" class="headerlink" title="顺序表的数据类型定义（一维数组表示法）"></a>顺序表的数据类型定义（一维数组表示法）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTSIZE_INC 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*数据记录的数据类型定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    keyType key; <span class="comment">//主关键字</span></span><br><span class="line">    InfoType info;</span><br><span class="line">&#125; ElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*顺序表的数组形式描述*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType *elem; <span class="comment">//基地址</span></span><br><span class="line">    <span class="type">int</span> size; <span class="comment">//当前表长</span></span><br><span class="line">    <span class="type">int</span> capacity; <span class="comment">//表容量</span></span><br><span class="line">&#125; SqList;</span><br></pre></td></tr></table></figure>

<p>顺序表的数组形式描述方式的特点：</p>
<ol>
<li>适用于表长未知且可能改变的场合（推荐）</li>
<li>对于表长已知的场合，可以采用固定空间分配的形式来定义<code>elem</code></li>
<li>可变表长虽然便捷，但是一定程度上存在存储空间的浪费</li>
</ol>
<h2 id="顺序表的基本操作"><a href="#顺序表的基本操作" class="headerlink" title="顺序表的基本操作"></a>顺序表的基本操作</h2><h3 id="CreateList（创建空表）"><a href="#CreateList（创建空表）" class="headerlink" title="CreateList（创建空表）"></a>CreateList（创建空表）</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/46936670/1726652292926-0d7f9e3c-a371-436d-a83b-ca6079abb597.jpeg"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*根据表容量创建一个空顺序表L*/</span></span><br><span class="line">Status <span class="title function_">CreateList</span><span class="params">(SqList &amp;L)</span> &#123;</span><br><span class="line">    L.elem = (ElemType *)<span class="built_in">malloc</span>(LIST_SIZE * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">    <span class="keyword">if</span> (!L.elem) <span class="keyword">return</span> OVERFLOW; <span class="comment">//存储分配失败</span></span><br><span class="line">    L.size = <span class="number">0</span>; <span class="comment">//空表</span></span><br><span class="line">    L.capacity = LIST_SIZE; </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//CreateList</span></span><br></pre></td></tr></table></figure>

<h3 id="LocateElem（查找元素）"><a href="#LocateElem（查找元素）" class="headerlink" title="LocateElem（查找元素）"></a>LocateElem（查找元素）</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/46936670/1726726197746-03ddc95e-d447-42ce-ab56-775cddebd835.jpeg"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*利用回调函数Compare在表L中查找元素e并返回其位序*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateElem</span> <span class="params">(SqList &amp;L, ElemType e, </span></span><br><span class="line"><span class="params">                Status (*Compare)(ElemType, ElemType))</span> &#123;</span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    p = L.elem;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= L.size &amp;&amp; !*Compare(*p++,e)) </span><br><span class="line">        ++i;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= L.size) </span><br><span class="line">        <span class="keyword">return</span> i; <span class="comment">//返回e所在位序</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//该元素不属于L</span></span><br><span class="line">&#125;<span class="comment">//LocateElem</span></span><br></pre></td></tr></table></figure>

<p>:::tips<br><strong>查找算法的时间复杂度分析</strong></p>
<p>平均时间复杂度分析：</p>
<p>$ T(n)&#x3D;\sum \limits^n_{i&#x3D;1}p_i \times i  $</p>
<p>$ p_i&#x3D;\frac{1}{n} $</p>
<p>$ \Rightarrow T(n)&#x3D;\frac{n+1}{2}&#x3D;O(n) $</p>
<p>因此 平均时间复杂度为$ O(n) $</p>
<p>最差时间复杂度：$ O(n) $</p>
<p>最好时间复杂度：$ O(1) $</p>
<p>:::</p>
<h3 id="InsertElem（插入元素）"><a href="#InsertElem（插入元素）" class="headerlink" title="InsertElem（插入元素）"></a>InsertElem（插入元素）</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/46936670/1726727760090-add5b8dd-b201-4cd5-b6dd-31c6a19f3afc.jpeg"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/46936670/1726727792800-2618aa4d-6758-4243-9fc3-d6a7fec62358.jpeg"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*向表L中第i个元素之前插入一个新元素e*/</span></span><br><span class="line">Status <span class="title function_">InsertElem</span> <span class="params">(SqList &amp;L, <span class="type">int</span> i, ElemType e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L.size+<span class="number">1</span>) <span class="keyword">return</span> ERROR; <span class="comment">//i值不合法</span></span><br><span class="line">    <span class="keyword">if</span> (L.size &gt;= L.capacity) &#123;</span><br><span class="line">        <span class="comment">//当前存储空间已满，增加分配</span></span><br><span class="line">        newbase = (ElemType *)<span class="built_in">realloc</span>(L.elem, (L.capacity+LISTSIZE_INC) * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">        <span class="keyword">if</span> (!newbase) <span class="keyword">return</span> OVERFLOW; <span class="comment">//存储分配失败</span></span><br><span class="line">        L.elem = newbase; <span class="comment">//新基址</span></span><br><span class="line">        L.capacity += LISTSIZE_INC; </span><br><span class="line">    &#125;</span><br><span class="line">    q = &amp;(L.elem[i<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (p = &amp;(L.elem[L.size<span class="number">-1</span>]); </span><br><span class="line">         p&gt;= q; --p) *(p+<span class="number">1</span>) = *p; <span class="comment">//插入位置及之后的元素右移</span></span><br><span class="line">    *q = e; <span class="comment">//插入e</span></span><br><span class="line">    ++L.size;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//InsertElem</span></span><br></pre></td></tr></table></figure>

<p>:::tips<br><strong>插入算法的时间复杂度分析</strong></p>
<p>平均时间复杂度分析</p>
<p>$ T(n)&#x3D;\sum \limits^{n+1}_{i&#x3D;1} p_i\left(n-i+1\right) $</p>
<p>$ p_i&#x3D;\frac{1}{n+1} $</p>
<p>$ \Rightarrow T(n)&#x3D;\frac{n}{2}&#x3D;O(n) $</p>
<p>平均时间复杂度：$ O(n) $</p>
<p>最差时间复杂度：$ O(n) $</p>
<p>最好时间复杂度：$ O(1) $</p>
<p>:::</p>
<h3 id="DeleteElem（删除元素）"><a href="#DeleteElem（删除元素）" class="headerlink" title="DeleteElem（删除元素）"></a>DeleteElem（删除元素）</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/46936670/1726728912992-9ef9ef90-1ecf-4305-b547-3e9b4523049e.jpeg"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*删除并返回表L中的第i个元素*/</span></span><br><span class="line">Status <span class="title function_">DeleteElem</span> <span class="params">(SqList &amp;L, <span class="type">int</span> i, ElemType &amp;e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L.size) </span><br><span class="line">        <span class="keyword">return</span> ERROR; <span class="comment">//i值不合法</span></span><br><span class="line">    p = &amp;(L.elem[i<span class="number">-1</span>]);</span><br><span class="line">    e = *p;</span><br><span class="line">    q = L.elem + L.size - <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span> (++p; p &lt;= q; ++p)*(p<span class="number">-1</span>) = *p; <span class="comment">//被删元素之后的元素左移</span></span><br><span class="line">    --L.size;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//DeleteElem</span></span><br></pre></td></tr></table></figure>

<p>:::tips<br><strong>删除算法的时间复杂度分析</strong></p>
<p>平均时间复杂度分析：</p>
<p>$ T(n)&#x3D;\sum \limits ^{n}_{i&#x3D;1} q_i\left(n-i\right) $</p>
<p>$ q_i&#x3D;\frac{1}{n} $</p>
<p>$ \Rightarrow T(n)&#x3D;\frac{n-1}{2}&#x3D;(n) $</p>
<p>平均时间复杂度：$ O(n) $</p>
<p>最差时间复杂度：$ O(n) $</p>
<p>最好时间复杂度：$ O(1) $</p>
<p>:::</p>
<h3 id="总结：顺序表的部分操作"><a href="#总结：顺序表的部分操作" class="headerlink" title="总结：顺序表的部分操作"></a>总结：顺序表的部分操作</h3><p>顺序表中常用的关键操作语句：</p>
<ol>
<li>判空条件：<code>L.size == 0</code></li>
<li>判满条件：<code>L.size == L.capacity</code></li>
<li>置表头：<code>p = L.elem</code></li>
<li>置表尾：<code>p = L.elem+L.size-1</code></li>
<li>访问数据元素操作：<code>e = *(L.elem+i-1)</code></li>
<li>数据元素右移操作：<code>*(p+1) = *p; --p;</code></li>
<li>数据元素左移操作：<code>*(p-1) = *p; ++p</code></li>
</ol>
<h2 id="顺序表的应用"><a href="#顺序表的应用" class="headerlink" title="顺序表的应用"></a>顺序表的应用</h2><p>:::tips<br>例3.1：已知两个线性表<code>La</code>和<code>Lb</code>分别表示集合$ A $和$ B $，求集合$ A&#x3D;A∪B $</p>
<p>:::</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/46936670/1727224102039-ac62817e-b03f-46b1-9083-7eef293f4698.jpeg"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/46936670/1727224103172-e3fecc5e-228a-4d66-b8bd-a8f5296135fc.jpeg"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*将所有在线性表Lb中但不在La中的数据元素插入到La中*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">union</span> <span class="params">(SqList &amp;La, SqList Lb)</span> &#123;</span><br><span class="line">    La_len = La.size; </span><br><span class="line">    Lb_len = Lb.size;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= Lb_len; i++) &#123; </span><br><span class="line">        GetElem(Lb, i, &amp;e); <span class="comment">//取Lb中第i个数据元素赋给e</span></span><br><span class="line">        <span class="keyword">if</span> (!LocateElem(La, e, Equal()))<span class="comment">//查询e在La中的位序,若不存则将e插入La尾部</span></span><br><span class="line">            InsertElem(&amp;La, ++La_len, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//union</span></span><br></pre></td></tr></table></figure>

<p>算法分析：</p>
<p>循环体内部：</p>
<ol>
<li>GetElem时间复杂度：$ O(1) $</li>
<li>LocateElem时间复杂度：$ O(La.size) $</li>
<li>InsertElem时间复杂度：$ O(1) $</li>
</ol>
<p>故该算法的时间复杂度为：$ O(La.size × Lb.size) $</p>
<p>:::tips<br>例3.2：已知两个线性表<code>La</code>和<code>Lb</code>分别表示集合$ A $和$ B $，且集合中的数据元素均按值非递减有序排列，求集合$ C&#x3D;A∪B $，且使$ C $中的数据元素仍按值非递减有序排列。</p>
<p>:::</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/46936670/1727224467550-02176deb-6ccb-484c-b68a-4230b91d0248.jpeg"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/46936670/1727224468544-d00a4db3-5a11-4cde-9a9c-eb38b2d167c4.jpeg"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*将两个有序表La和Lb的元素合并至新表Lc中，并保持Lc有序*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeList</span><span class="params">(SqList La, SqList Lb, SqList &amp;Lc)</span> &#123;</span><br><span class="line">    pa = La.elem; </span><br><span class="line">    pb = Lb.elem;</span><br><span class="line">    Lc.capacity = Lc.size = La.size + Lb.size;</span><br><span class="line">    pc = Lc.elem = (ElemType *)<span class="built_in">malloc</span>(Lc.capacity * <span class="keyword">sizeof</span>(ELemType));</span><br><span class="line">    <span class="keyword">if</span> (!pc) </span><br><span class="line">        <span class="keyword">return</span> OVERFLOW;</span><br><span class="line">    pa_last = La.elem+La.size - <span class="number">1</span>;</span><br><span class="line">    pb_last = Lb.elem+Lb.size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (pa &lt;= pa_last &amp;&amp; pb &lt;= pb_last) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*pa &lt;= *pb) </span><br><span class="line">            *pc++=*pa++; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            *pc++ = *pb++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (pa &lt;= pa_last) </span><br><span class="line">        *pc++ = *pa++;</span><br><span class="line">    <span class="keyword">while</span> (pb &lt;= pb_last) </span><br><span class="line">        *pc++ = *pb++;</span><br><span class="line">&#125;<span class="comment">//MergeList</span></span><br></pre></td></tr></table></figure>

<p>算法分析：循环体内部：</p>
<ol>
<li>选择语句时间复杂度：$ O(1) $</li>
<li>赋值语句时间复杂度：$ O(1) $</li>
</ol>
<p>故该算法的时间复杂度为：$ O(La.size + Lb.size) $</p>
<h3 id="小结顺序表的优缺点"><a href="#小结顺序表的优缺点" class="headerlink" title="小结顺序表的优缺点"></a>小结顺序表的优缺点</h3><ul>
<li>顺序表的优点：</li>
</ul>
<ol>
<li>可以随机存取任一数据元素，访问时间开销$ O(1) $</li>
<li>存储密度高，数据结构逻辑关系的表达不占用额外存储空间</li>
</ol>
<ul>
<li>顺序表的缺点：</li>
</ul>
<ol>
<li>插入和删除操作需移动大量数据元素，平均时间开销$ O(n) $</li>
<li>静态固定存储空间的分配方式可能一定程度上导致存储空间的浪费</li>
<li>扩增顺序表需要重新创建一个新表，完成数据整体复制后再释放原表</li>
</ol>
<h1 id="三、线性表的链式表示"><a href="#三、线性表的链式表示" class="headerlink" title="三、线性表的链式表示"></a>三、线性表的链式表示</h1><h2 id="单链表的定义"><a href="#单链表的定义" class="headerlink" title="单链表的定义"></a>单链表的定义</h2><h3 id="线性表的链式表示（线性链表）"><a href="#线性表的链式表示（线性链表）" class="headerlink" title="线性表的链式表示（线性链表）"></a>线性表的链式表示（线性链表）</h3><p>链：用指针表示数据元素之间的逻辑关系</p>
<p>线性链表：用一组位置随机分布的存储单元（结点）存储数据元素，并采用后继链存储元素间关系的线性表，也称为单链表</p>
<h3 id="结点结构"><a href="#结点结构" class="headerlink" title="结点结构"></a>结点结构</h3><p>data（数据域）+next（指针域）</p>
<p>结点结构：存储数据元素信息的域称为数据域，存储直接后继存储位置的域称为指针域，两者共同构成一个结点（node)</p>
<p>:::tips<br>例1.1：单链表的逻辑结构与存储结构。</p>
<p>:::</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/46936670/1727224985701-5056a6a1-6ca8-4ce6-a549-8cd7c1af3417.jpeg"></p>
<h3 id="单链表的结构指针描述法"><a href="#单链表的结构指针描述法" class="headerlink" title="单链表的结构指针描述法"></a>单链表的结构指针描述法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElemType data; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LNode, *LinkList;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*不带头结点的空链表*/</span></span><br><span class="line">LinkList L;</span><br><span class="line">L = <span class="literal">NULL</span>; <span class="comment">//头指针置为空</span></span><br></pre></td></tr></table></figure>

<p>头指针：指向链表的第一个节点的<code>LNode</code>型指针变量，例如<code>L</code></p>
<p>空链表：对于空表，则满足头指针<code>L==NULL</code></p>
<h3 id="头结点"><a href="#头结点" class="headerlink" title="头结点"></a>头结点</h3><p>头结点：在表头额外附加的一个<code>LNode</code>型结点，以提高链表操作效率，头结点的数据域可额外存储链表信息（例如表长）</p>
<p>空链表：头指针<code>L</code>指向头结点，对于空表，满足<code>L-&gt;next==NULL</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*带头结点的空链表*/</span> </span><br><span class="line">LinkList L; </span><br><span class="line">L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (LNode)); </span><br><span class="line">L-&gt;next=<span class="literal">NULL</span>;<span class="comment">//创建头结点并置空</span></span><br></pre></td></tr></table></figure>

<h3 id="单链表的数组描述法（静态链表）"><a href="#单链表的数组描述法（静态链表）" class="headerlink" title="单链表的数组描述法（静态链表）"></a>单链表的数组描述法（静态链表）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_SIZE 1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data; </span><br><span class="line">    <span class="type">int</span> cur; <span class="comment">//下标作链</span></span><br><span class="line">&#125; LNode, SLinkList[LIST_SIZE];</span><br></pre></td></tr></table></figure>

<h2 id="单链表的基本操作"><a href="#单链表的基本操作" class="headerlink" title="单链表的基本操作"></a>单链表的基本操作</h2><h3 id="GetElem（访问元素）"><a href="#GetElem（访问元素）" class="headerlink" title="GetElem（访问元素）"></a>GetElem（访问元素）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*在带头结点的链表L中按位序i查找并返回元素至e*/</span></span><br><span class="line">Status <span class="title function_">GetElem</span> <span class="params">(LinkList L, <span class="type">int</span> i, ElemType &amp;e)</span> &#123;</span><br><span class="line">    p = L-&gt;next; </span><br><span class="line">    j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; j &lt; i) &#123;</span><br><span class="line">        p = p-&gt;next; </span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p || j&gt;i) </span><br><span class="line">        <span class="keyword">return</span> ERROR; </span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//GetElem</span></span><br></pre></td></tr></table></figure>

<p>访问第i个数据元素必须从头结点出发，查找操作的平均时间复杂度$ O(n) $</p>
<h3 id="InsertElem（插入元素）-1"><a href="#InsertElem（插入元素）-1" class="headerlink" title="InsertElem（插入元素）"></a>InsertElem（插入元素）</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/46936670/1727225623329-4ba64b1e-2595-4a09-bb80-5803286cc247.jpeg"></p>
<p>插入操作：<code>s-&gt;next = p-&gt;next; p-&gt;next = s;</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*将元素e插入带头结点的链表L的位序i处*/</span></span><br><span class="line">Status <span class="title function_">InsertElem</span> <span class="params">(LinkList L, <span class="type">int</span> i, ElemType e)</span> &#123;</span><br><span class="line">    p = L; </span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;</span><br><span class="line">        p = p-&gt;next; ++j;</span><br><span class="line">    &#125; <span class="comment">//查找</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!p || j &gt; i) </span><br><span class="line">        <span class="keyword">return</span> ERROR; </span><br><span class="line">    s = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Lnode));</span><br><span class="line">    s-&gt;data = e; </span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;<span class="comment">//插入</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//InsertElem</span></span><br></pre></td></tr></table></figure>

<p>查找操作的平均时间复杂度：$ O(n) $</p>
<p>插入操作的平均时间复杂度：$ O(1) $</p>
<h3 id="DeleteElem（删除元素）-1"><a href="#DeleteElem（删除元素）-1" class="headerlink" title="DeleteElem（删除元素）"></a>DeleteElem（删除元素）</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/46936670/1727225879266-7d310292-53d8-461b-8802-f21d011461cc.jpeg"></p>
<p>删除操作：<code>q = p-&gt;next; p-&gt;next = q-&gt;next; free(q);</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*将位序i结点从带头结点的链表L中删除并返回其元素至e*/</span></span><br><span class="line">Status <span class="title function_">DeleteElem</span> <span class="params">(LinkList L, <span class="type">int</span> i, ElemType &amp;e)</span> &#123;</span><br><span class="line">    p = L-&gt;next; </span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; j&lt;i<span class="number">-1</span>) &#123;</span><br><span class="line">        p = p-&gt;next; </span><br><span class="line">        ++j;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (!p || j &gt; i - <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> ERROR; </span><br><span class="line">    q = p-&gt;next; </span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    e = q-&gt;data; </span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;<span class="comment">//DeleteElem</span></span><br></pre></td></tr></table></figure>

<p>查找操作的平均时间复杂度：$ O(n) $</p>
<p>插入操作的平均时间复杂度：$ O(1) $</p>
<h3 id="CreateList（逆向创建单链表）"><a href="#CreateList（逆向创建单链表）" class="headerlink" title="CreateList（逆向创建单链表）"></a>CreateList（逆向创建单链表）</h3><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/46936670/1727226066735-20a60d8d-646e-4f36-adf5-f1cd91dfb181.jpeg"></p>
<h3 id="小结：单链表的常用操作"><a href="#小结：单链表的常用操作" class="headerlink" title="小结：单链表的常用操作"></a>小结：单链表的常用操作</h3><ol>
<li>判空条件：<code>L == NULL</code> or <code>L-&gt;next == NULL</code></li>
<li>判尾条件：<code>p-&gt;next == NULL</code></li>
<li>置表头：<code>p = L or p = L-&gt;next</code></li>
<li>置表尾：<code>while (p-&gt;next) p = p-&gt;next;</code></li>
<li>访问元素：<code>e = p-&gt;data</code></li>
<li>后插入：<code>s-&gt;next = p-&gt;next; p-next = s;</code></li>
<li>删除：<code>q = p-&gt;next; p-&gt;next = q-&gt;next; free(q);</code></li>
</ol>
<h3 id="单链表的优缺点"><a href="#单链表的优缺点" class="headerlink" title="单链表的优缺点"></a>单链表的优缺点</h3><ol>
<li>每个结点的存储空间在物理位置上不要求用地址连续</li>
<li>插入、删除不需要移动元素，时间复杂度为$ O(1) $</li>
<li>不必事先预知表长，可动态利用计算机的内存空间</li>
<li>只能顺序存取访问，不具备随机存取特点，位序概念淡化</li>
<li>链表结点增加了指示元素间关系的指针域，存储密度相对低一些</li>
</ol>
<h2 id="链表的应用"><a href="#链表的应用" class="headerlink" title="链表的应用"></a>链表的应用</h2><p>:::tips<br>例3.1：已知两个线性链表<code>La</code>和<code>Lb</code>分别表示集合$ A $和$ B $，且集合中的数据元素均按值非递减有序排列，求集合$ C&#x3D;A∪B $，且使$ C $中的数据元素仍按值非递减有序排列。</p>
<p>:::</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*合并两个有序链表*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeList</span><span class="params">(LinkList La, LinkList Lb, LinkList &amp;Lc)</span> &#123;</span><br><span class="line">    pa = La-&gt;next; </span><br><span class="line">    Lc = La; <span class="comment">//Lc复用La的头结点</span></span><br><span class="line">    pb = Lb-&gt;next; </span><br><span class="line">    <span class="built_in">free</span>(Lb);</span><br><span class="line">    pc = Lc;</span><br><span class="line">    <span class="keyword">while</span> (pa &amp;&amp; pb) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pa-&gt;data &lt;= pb-&gt;data) &#123;</span><br><span class="line">            pc-&gt;next = pa; </span><br><span class="line">            pc = pa; </span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pc-&gt;next = pb; </span><br><span class="line">            pc = pb; </span><br><span class="line">            pb = pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pa) </span><br><span class="line">        pc-&gt;next = pa;</span><br><span class="line">    <span class="keyword">else</span> pc-&gt;next = pb;</span><br><span class="line">&#125;<span class="comment">//MergeList</span></span><br></pre></td></tr></table></figure>

<p>:::tips<br>例3.2：已知单链表的头指针head，请查找该链表从尾部开始数的第n个结点。</p>
<p>:::</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/46936670/1727226579742-1cf4ebb9-8fc4-4a0f-9694-b74e6c72df9c.jpeg"></p>
<blockquote>
<p>算法思路1：蛮力搜索法</p>
<p>初始化：设置两个均指向头结点的辅助指针p和q。</p>
<p>步骤1：令q指向p的下一个结点，并从该结点开始遍历链表，求出表长m。</p>
<p>步骤2：如果表长m&lt;n则退出，m&#x3D;n则返回p所指结点，m&gt;n则执行步骤3。</p>
<p>步骤3：p向后移动一步p，重新执行步骤1。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*算法思路1：蛮力法*/</span></span><br><span class="line">LNode *<span class="title function_">NthNodeFromEnd</span><span class="params">(LinkList head, <span class="type">int</span> n)</span> &#123; </span><br><span class="line">    LNode *p = head, *q;</span><br><span class="line">    <span class="type">int</span> count; </span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (q!=<span class="literal">NULL</span>) &#123; <span class="comment">//判定表尾</span></span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count &lt; n) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//查找失败</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(count == n) </span><br><span class="line">            <span class="keyword">return</span> q; <span class="comment">//查找成功</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            p = p-&gt;next; <span class="comment">//继续下一轮查找</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//NthNodeFromEnd</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>算法思路2：两次遍历法</p>
<p>初始化：设置一个指向头结点的辅助指针p。</p>
<p>步骤1：p从首元结点开始遍历链表，求出表长m。</p>
<p>步骤2：如果表长m&lt;n则退出；否则执行步骤3。</p>
<p>步骤3：计算m-n+1的值。</p>
<p>步骤4：再置p从首元结点开始遍历链表，找到并返回第m-n+1个结点。</p>
<p>算法思路3：单次遍历法</p>
<p>初始化：设置两个均指向头结点的辅助指针p和q。</p>
<p>步骤1：p从首元结点开始遍历链表，直至p指向第n个结点为止。</p>
<p>步骤2：两个指针同时向后移动，直至p到达表尾为止。</p>
<p>步骤3：返回q所指结点。</p>
</blockquote>
<p>:::tips<br>例3.3：已知单链表的头指针head，请将该链表逆置。（逆置前后如下所示）</p>
<p>:::</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/46936670/1727226862681-6a0f856c-bc0c-4228-ab25-da5e883e946b.jpeg"></p>
<blockquote>
<p>算法设计思路1：迭代法</p>
<p>初始化：设置两个辅助指针，p指向链表首元结点，last置空。</p>
<p>步骤1：保存p的直接后继结点地址给q。</p>
<p>步骤2：将p的直接后继指向原直接前驱last。</p>
<p>步骤3：p和last指针同时后移，使p指向下一待处理结点。</p>
<p>步骤4：重复执行步骤1-3，直至达到链尾为止。</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/46936670/1727226920801-8637aa6a-c93a-4565-99e2-e5b43a26e1b7.jpeg"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/46936670/1727226954435-e7e406c3-8008-48e0-83c8-5cd6d749f8e1.jpeg"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/46936670/1727226979070-129b8666-f052-4973-863c-1b09766d8674.jpeg"></p>
<blockquote>
<p>算法设计思路2：分治与递归法</p>
<p>步骤1：将链表L分解为仅含首元结点p及由其直接后继q指示的Ln链表。</p>
<p>步骤2：将首元结点p的直接后继置空。</p>
<p>步骤3：递归处理Ln链表的逆置问题。</p>
<p>步骤4：置q的直接后继为p，实现逆序合并。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*算法思路2：分治与递归法*/</span></span><br><span class="line">LinkList <span class="title function_">ReverseList</span><span class="params">(LinkList head)</span> &#123; </span><br><span class="line">    Linklist secondNode, revHead;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    secondNode = head-&gt;next;</span><br><span class="line">    revHead = ReverseList(secondNode);</span><br><span class="line">    secondNode-&gt;next = head;</span><br><span class="line">    Head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> revHead;</span><br><span class="line">&#125;<span class="comment">//ReverseList</span></span><br></pre></td></tr></table></figure>

<h3 id="顺序表与链表的比较"><a href="#顺序表与链表的比较" class="headerlink" title="顺序表与链表的比较"></a>顺序表与链表的比较</h3><table>
<thead>
<tr>
<th></th>
<th>顺序表</th>
<th>链表</th>
</tr>
</thead>
<tbody><tr>
<td>表长</td>
<td>固定</td>
<td>可变</td>
</tr>
<tr>
<td>存储结构</td>
<td>顺序、静态</td>
<td>链式、动态</td>
</tr>
<tr>
<td>存储密度</td>
<td>高</td>
<td>相对低</td>
</tr>
<tr>
<td>插入、删除操作时间复杂度</td>
<td>$ O(n) $</td>
<td>$ O(1) $</td>
</tr>
<tr>
<td>访问操作时间复杂度</td>
<td>$ O(1) $</td>
<td>$ O(n) $</td>
</tr>
</tbody></table>
<p>数据结构的设计实现策略：</p>
<ol>
<li>确定数据对象：加工实际问题中所涉及数据集合</li>
<li>确定逻辑结构：建立实际问题中数据元素之间的逻辑关系</li>
<li>确定存储结构：根据实际问题中是否需要插入、删除等操作进行选择</li>
<li>确定基本操作：设计实际问题中最频繁使用的最小操作子集</li>
</ol>
<h1 id="四、线性结构的深入"><a href="#四、线性结构的深入" class="headerlink" title="四、线性结构的深入"></a>四、线性结构的深入</h1><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><h3 id="循环链表-1"><a href="#循环链表-1" class="headerlink" title="循环链表"></a>循环链表</h3><p>循环链表：链表中最后一个结点的指针指向头结点，形成一个环</p>
<p>典型特点：从表中任一结点出发均可访问其他结点</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/46936670/1727330805088-b9c341e3-97eb-4045-9d30-317d34737148.jpeg"></p>
<h3 id="循环链表的基本操作"><a href="#循环链表的基本操作" class="headerlink" title="循环链表的基本操作"></a>循环链表的基本操作</h3><p>循环链表的常用基本操作：</p>
<ol>
<li>访问头结点：<code>head</code>或<code>p-&gt;next</code></li>
<li>判空条件：<code>head-&gt;next == head</code></li>
<li>遍历结束条件：<code>p-&gt;next == head</code></li>
</ol>
<h3 id="尾指针"><a href="#尾指针" class="headerlink" title="尾指针"></a>尾指针</h3><p>指向循环链表的最后一个结点的<code>LNode</code>型指针变量，例如<code>rear</code>，其作用等价于头指针<code>head</code></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/46936670/1727331027662-6ffbbec4-6e9f-4137-bb12-d8c8c35e4ef8.jpeg"></p>
<h3 id="尾指针引导的循环链表的基本操作"><a href="#尾指针引导的循环链表的基本操作" class="headerlink" title="尾指针引导的循环链表的基本操作"></a>尾指针引导的循环链表的基本操作</h3><ol>
<li>访问头结点：<code>rear-&gt;next</code></li>
<li>访问首元结点：<code>rear-&gt;next-&gt;next</code></li>
<li>尾插入结点s：<code>s-&gt;next=rear-&gt;next</code>;<code>rear-&gt;next=s;rear=s;</code></li>
</ol>
<p>:::tips<br>例1.1：已知某链表的头指针L，请判断该链表是以指针域为NULL的结点结束还是以一个循环链表结束。(如下图所示）</p>
<p>:::</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/46936670/1727331193402-1602d718-35a9-4b8d-835a-09794387936d.jpeg"></p>
<p>算法设计思路：Floyd-cycle-finding算法</p>
<p>初始化：设置移动速度不同的两个辅助指针fast与slow，指向链表首元结点。</p>
<p>步骤1：fast指针以每次移动两个位置向链尾快速移动。</p>
<p>步骤2：slow指针以每次移动一个位置向链尾移动。</p>
<p>步骤3：重复执行步骤1-2，直至fast达到链尾（无环），或fast追赶上slow为止（有环）。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/46936670/1727331262252-5e17f7a9-fe16-4fac-a9a2-c8fc8ac62432.jpeg"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/46936670/1727331299061-574386f3-fe26-490c-8fc1-92bb2f879a02.jpeg"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/46936670/1727331336852-5b0b6be1-ac1b-4b9c-9fa7-35839492d41c.jpeg"></p>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><h3 id="双向链表-1"><a href="#双向链表-1" class="headerlink" title="双向链表"></a>双向链表</h3><p>在结点中使用两个指针域，分别指向当前结点的直接前驱和直接后驱</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> &#123;</span></span><br><span class="line">    ElemType data; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">prior</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; DuLNode, *DuLinkList;</span><br></pre></td></tr></table></figure>

<h3 id="双向链表的插入操作"><a href="#双向链表的插入操作" class="headerlink" title="双向链表的插入操作"></a>双向链表的插入操作</h3><p>修改指针的语句：</p>
<ol>
<li><code>s-&gt;next=p;</code></li>
<li><code>s-&gt;prior=p-&gt;prior;</code></li>
<li><code>p-&gt;prior-&gt;next=s;</code></li>
<li><code>p-&gt;prior=s</code></li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/46936670/1727331554119-d198f098-3a21-4041-a741-6515c1d6f944.jpeg"></p>
<h3 id="双向链表的删除操作"><a href="#双向链表的删除操作" class="headerlink" title="双向链表的删除操作"></a>双向链表的删除操作</h3><p>修改指针的语句：</p>
<ol>
<li><code>p-&gt;prior-&gt;next=p-&gt;next;</code></li>
<li><code>p-&gt;next-&gt;prior=p-&gt;prior;</code></li>
<li><code>free(p)</code></li>
</ol>
<h3 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h3><p>在双向链表的基础上，要求<code>rear-&gt;next=head</code>及<code>head-&gt;prior=rear</code></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/46936670/1727331702593-a645ee8f-6419-4e67-a297-d39a5ae10992.jpeg"></p>
<h3 id="双向循环链表的判空条件"><a href="#双向循环链表的判空条件" class="headerlink" title="双向循环链表的判空条件"></a>双向循环链表的判空条件</h3><p><code>L-&gt;next == L</code> 且 <code>L-&gt;prior == L</code></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/46936670/1727331832563-ac3e7079-ad2c-4841-b0b9-2ce6dc572952.jpeg"></p>
<h2 id="有序表"><a href="#有序表" class="headerlink" title="有序表"></a>有序表</h2><h3 id="有序表-1"><a href="#有序表-1" class="headerlink" title="有序表"></a>有序表</h3><p>线性表中的所有数据元素按其关键字大小顺序排列</p>
<h3 id="一元多项式"><a href="#一元多项式" class="headerlink" title="一元多项式"></a>一元多项式</h3><h4 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计</h4><p>数据对象的构造：</p>
<ol>
<li>使用线性表表示系数项：（p0, p1, p2, …, pn）</li>
<li>使用线性表表示系数项与指数项：（&lt;p0, 0&gt;, &lt;p1, 1&gt;, &lt;p2, 2&gt;, …, &lt;pn, n&gt;）</li>
</ol>
<h4 id="一元多项式的ADT定义"><a href="#一元多项式的ADT定义" class="headerlink" title="一元多项式的ADT定义"></a>一元多项式的ADT定义</h4><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/46936670/1727332117183-829699dd-7f55-4a0b-9fef-6c9abe477669.jpeg"></p>
<h4 id="一元多项式的单链表表示"><a href="#一元多项式的单链表表示" class="headerlink" title="一元多项式的单链表表示"></a>一元多项式的单链表表示</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LNode, *LinkList;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Typedef <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">float</span> coef;</span><br><span class="line">    <span class="type">int</span> expn;</span><br><span class="line">&#125; ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Linklist polynomial;</span><br></pre></td></tr></table></figure>

<h4 id="AddPolyn（两个多项式求和）"><a href="#AddPolyn（两个多项式求和）" class="headerlink" title="AddPolyn（两个多项式求和）"></a>AddPolyn（两个多项式求和）</h4><p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/46936670/1727332413019-c4feeb8c-844f-484a-bd19-8e62cd2f7733.jpeg"></p>
<p>求和过程（用<code>Pa</code>存储求和结果)：</p>
<ol>
<li><code>case1 (ai.expn &gt; bj.expn)</code> :将结点<code>qb</code>插入<code>Pa</code>并从<code>Pb</code>删除</li>
<li><code>case2 (ai.expn == bj.expn)</code> : 求和并从<code>Pb</code>删除结点<code>qb</code>, 若求和为0则同时从<code>Pa</code>删除结点<code>qa</code></li>
<li><code>case3 (ai.expn &lt; bj.expn)</code> :将<code>qa</code>移至其直接后继</li>
</ol>
<p>:::tips<br>例3.1：用一张顺序表L有序存放一组数据，请删除其中重复出现的元素，使得每个元素只出现一次</p>
<p>:::</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*删除有序表中的重复元素*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PurgeDup</span> <span class="params">(SqList &amp;L)</span> &#123;</span><br><span class="line">    slow = <span class="number">0</span>; </span><br><span class="line">    fast = <span class="number">1</span>; <span class="comment">//设定快慢两个下标</span></span><br><span class="line">    <span class="keyword">while</span> (fast &lt; L.size) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.elem[fast] != L.elem[slow]) &#123;</span><br><span class="line">            slow++;</span><br><span class="line">            L.elem[slow] = L.elem[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    L.size = slow+<span class="number">1</span>; <span class="comment">//被删元素之后的元素左移</span></span><br><span class="line">&#125;<span class="comment">//PurgeDup</span></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://yanc-blog.zeabur.app">Yan Cheng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://yanc-blog.zeabur.app/2024/09/25/ch2/">https://yanc-blog.zeabur.app/2024/09/25/ch2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/">课堂笔记</a><a class="post-meta__tags" href="/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/">线性表</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.pixabay.com/photo/2024/07/06/08/10/flowers-8876324_1280.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2024/09/24/my_introduction/" title="我的第一篇博客"><img class="cover" src="https://cdn.pixabay.com/photo/2024/07/06/08/10/flowers-8876324_1280.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">我的第一篇博客</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/image.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Yan Cheng</div><div class="author-info__description">欢迎加QQ2577979885交流！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yanc-USTC"><i class="fab fa-github"></i><span>关注Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yanc-USTC" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/2577979885@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">本站所有blog均由作者yanc原创，转载请注明出处！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">一、线性表的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.</span> <span class="toc-text">线性表的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.1.</span> <span class="toc-text">线性结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%EF%BC%88Linear-List%EF%BC%89"><span class="toc-number">1.1.2.</span> <span class="toc-text">线性表（Linear List）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%EF%BC%88ADT%E5%AE%9A%E4%B9%89%EF%BC%89"><span class="toc-number">1.1.3.</span> <span class="toc-text">线性表的抽象数据类型定义（ADT定义）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.</span> <span class="toc-text">线性表的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E9%9B%86"><span class="toc-number">1.2.1.</span> <span class="toc-text">线性表的基本操作集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BBC%E4%BC%AA%E4%BB%A3%E7%A0%81%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-number">1.2.2.</span> <span class="toc-text">类C伪代码（推荐）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.</span> <span class="toc-text">二、线性表的顺序表示</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.</span> <span class="toc-text">顺序表的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA%EF%BC%88%E9%A1%BA%E5%BA%8F%E8%A1%A8%EF%BC%89"><span class="toc-number">2.1.1.</span> <span class="toc-text">线性表的顺序表示（顺序表）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%EF%BC%88%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%89"><span class="toc-number">2.1.2.</span> <span class="toc-text">顺序表的数据类型定义（一维数组表示法）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.</span> <span class="toc-text">顺序表的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CreateList%EF%BC%88%E5%88%9B%E5%BB%BA%E7%A9%BA%E8%A1%A8%EF%BC%89"><span class="toc-number">2.2.1.</span> <span class="toc-text">CreateList（创建空表）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LocateElem%EF%BC%88%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%EF%BC%89"><span class="toc-number">2.2.2.</span> <span class="toc-text">LocateElem（查找元素）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InsertElem%EF%BC%88%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0%EF%BC%89"><span class="toc-number">2.2.3.</span> <span class="toc-text">InsertElem（插入元素）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DeleteElem%EF%BC%88%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%EF%BC%89"><span class="toc-number">2.2.4.</span> <span class="toc-text">DeleteElem（删除元素）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E9%83%A8%E5%88%86%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.5.</span> <span class="toc-text">总结：顺序表的部分操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">2.3.</span> <span class="toc-text">顺序表的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.3.1.</span> <span class="toc-text">小结顺序表的优缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E8%A1%A8%E7%A4%BA"><span class="toc-number">3.</span> <span class="toc-text">三、线性表的链式表示</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.</span> <span class="toc-text">单链表的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E8%A1%A8%E7%A4%BA%EF%BC%88%E7%BA%BF%E6%80%A7%E9%93%BE%E8%A1%A8%EF%BC%89"><span class="toc-number">3.1.1.</span> <span class="toc-text">线性表的链式表示（线性链表）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E7%82%B9%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.2.</span> <span class="toc-text">结点结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84%E6%8C%87%E9%92%88%E6%8F%8F%E8%BF%B0%E6%B3%95"><span class="toc-number">3.1.3.</span> <span class="toc-text">单链表的结构指针描述法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%B4%E7%BB%93%E7%82%B9"><span class="toc-number">3.1.4.</span> <span class="toc-text">头结点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%95%B0%E7%BB%84%E6%8F%8F%E8%BF%B0%E6%B3%95%EF%BC%88%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%EF%BC%89"><span class="toc-number">3.1.5.</span> <span class="toc-text">单链表的数组描述法（静态链表）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">3.2.</span> <span class="toc-text">单链表的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GetElem%EF%BC%88%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0%EF%BC%89"><span class="toc-number">3.2.1.</span> <span class="toc-text">GetElem（访问元素）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InsertElem%EF%BC%88%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0%EF%BC%89-1"><span class="toc-number">3.2.2.</span> <span class="toc-text">InsertElem（插入元素）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DeleteElem%EF%BC%88%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%EF%BC%89-1"><span class="toc-number">3.2.3.</span> <span class="toc-text">DeleteElem（删除元素）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CreateList%EF%BC%88%E9%80%86%E5%90%91%E5%88%9B%E5%BB%BA%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%89"><span class="toc-number">3.2.4.</span> <span class="toc-text">CreateList（逆向创建单链表）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%EF%BC%9A%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">3.2.5.</span> <span class="toc-text">小结：单链表的常用操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">3.2.6.</span> <span class="toc-text">单链表的优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">3.3.</span> <span class="toc-text">链表的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">3.3.1.</span> <span class="toc-text">顺序表与链表的比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E7%9A%84%E6%B7%B1%E5%85%A5"><span class="toc-number">4.</span> <span class="toc-text">四、线性结构的深入</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">4.1.</span> <span class="toc-text">循环链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8-1"><span class="toc-number">4.1.1.</span> <span class="toc-text">循环链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">4.1.2.</span> <span class="toc-text">循环链表的基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%BE%E6%8C%87%E9%92%88"><span class="toc-number">4.1.3.</span> <span class="toc-text">尾指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%BE%E6%8C%87%E9%92%88%E5%BC%95%E5%AF%BC%E7%9A%84%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">4.1.4.</span> <span class="toc-text">尾指针引导的循环链表的基本操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">4.2.</span> <span class="toc-text">双向链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-1"><span class="toc-number">4.2.1.</span> <span class="toc-text">双向链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">4.2.2.</span> <span class="toc-text">双向链表的插入操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">4.2.3.</span> <span class="toc-text">双向链表的删除操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">4.2.4.</span> <span class="toc-text">双向循环链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A4%E7%A9%BA%E6%9D%A1%E4%BB%B6"><span class="toc-number">4.2.5.</span> <span class="toc-text">双向循环链表的判空条件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E8%A1%A8"><span class="toc-number">4.3.</span> <span class="toc-text">有序表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E8%A1%A8-1"><span class="toc-number">4.3.1.</span> <span class="toc-text">有序表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F"><span class="toc-number">4.3.2.</span> <span class="toc-text">一元多项式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">数据结构设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84ADT%E5%AE%9A%E4%B9%89"><span class="toc-number">4.3.2.2.</span> <span class="toc-text">一元多项式的ADT定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA"><span class="toc-number">4.3.2.3.</span> <span class="toc-text">一元多项式的单链表表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AddPolyn%EF%BC%88%E4%B8%A4%E4%B8%AA%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E5%92%8C%EF%BC%89"><span class="toc-number">4.3.2.4.</span> <span class="toc-text">AddPolyn（两个多项式求和）</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/09/25/ch2/" title="线性表"><img src="https://cdn.pixabay.com/photo/2024/07/06/08/10/flowers-8876324_1280.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="线性表"/></a><div class="content"><a class="title" href="/2024/09/25/ch2/" title="线性表">线性表</a><time datetime="2024-09-24T16:00:00.000Z" title="Created 2024-09-25 00:00:00">2024-09-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/24/my_introduction/" title="我的第一篇博客"><img src="https://cdn.pixabay.com/photo/2024/07/06/08/10/flowers-8876324_1280.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="我的第一篇博客"/></a><div class="content"><a class="title" href="/2024/09/24/my_introduction/" title="我的第一篇博客">我的第一篇博客</a><time datetime="2024-09-23T16:00:00.000Z" title="Created 2024-09-24 00:00:00">2024-09-24</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.pixabay.com/photo/2024/05/10/10/29/atmosphere-8752835_1280.png')"><div id="footer-wrap"><div class="copyright">&copy;2024 By Yan Cheng</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">我是有底线的。</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const initGitalk = () => {
    const gitalk = new Gitalk(Object.assign({
      clientID: 'Ov23liOZsBfAumI3hQLX',
      clientSecret: 'c81119fe44c9a41f20f8aed765df36fbe784347b',
      repo: 'https://github.com/yanc-USTC/gitalk',
      owner: 'yanc-USTC',
      admin: ['yanc-USTC'],
      id: '450b04e8d46611887f838adeb54dc03e',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async() => {
    if (typeof Gitalk === 'function') initGitalk()
    else {
      await getCSS('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.css')
      await getScript('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js')
      initGitalk()
    }
  }
  
  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  if ('Gitalk' === 'Gitalk' || !true) {
    if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>